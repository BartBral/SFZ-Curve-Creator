<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SFZ Velocity Curve Generator - Fixed B-Spline and Output</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #99a2ea;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: left;
    }

    h1 {
      margin-top: 1em;
      font-size: 1.8em;
      text-align: left;
    }

    p {
      max-width: 600px;
      margin: 0.5em auto 1em auto;
      line-height: 1.4;
      text-align: left;
    }

    .main-container {
      display: flex;
      margin-bottom: 2em;
    }

    .left-panel {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    .graph-container {
      position: relative;
      width: 420px;
      height: 420px;
      border: 1px solid #2d713e;
      background: white;
      margin-bottom: 6px;
    }

    #curve {
      width: 420px;
      height: 420px;
    }

    #curve canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #x-axis-labels {
      margin-top: 2px;
      width: 420px;
      display: flex;
      justify-content: space-between;
      font-weight: bold;
      font-size: 12px;
      color: black;
      user-select: none;
    }

    #y-axis-labels {
      position: absolute;
      left: -30px;
      top: 0;
      height: 420px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      font-weight: bold;
      font-size: 12px;
      color: black;
      pointer-events: none;
      text-align: right;
    }

    #sfz-graph-container {
      width: 420px;
      height: 420px;
      border: 1px solid #777;
      background: #fafafa;
      margin-top: 18px;
    }

    #sfz-graph {
      width: 420px;
      height: 420px;
      margin-top: 0px;
    }

    .mode-controls {
      margin-top: 16px;
      width: 420px;
      user-select: none;
    }

    .mode-controls label {
      margin-right: 4px;
      cursor: pointer;
    }

    .mode-controls input[type="radio"] {
      margin-right: 4px;
    }

    #output-container {
      margin-left: 24px;
      width: 320px;
      display: flex;
      flex-direction: column;
    }

    #output {
      flex-grow: 1;
      height: 420px;
      padding: 8px;
      background: #f0f0f5;
      font-family: monospace;
      white-space: pre-wrap;
      overflow-y: auto;
      border: 1px solid #777;
      border-radius: 4px;
      user-select: text;
    }

    button.copy-btn {
      margin-top: 12px;
      padding: 8px 20px;
      background: #3b6ce1;
      border: none;
      color: #fff;
      font-weight: bold;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }

    button.copy-btn:hover {
      background: #2b55b8;
    }

    #copy-message {
      font-weight: bold;
      color: rgb(0, 255, 0);
      margin-left: 12px;
      align-self: center;
      user-select: none;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    #copy-message.visible {
      opacity: 1;
    }
  </style>
</head>

<body>
  <h1>SFZ Velocity Curve Generator</h1>
  <p>Drag points to change the curve.<br />Double-click a point (except first/last) to delete.<br />Switch modes and
    press "Copy code" to copy SFZ output.</p>

  <div class="main-container">
    <div class="left-panel">
      <div class="graph-container" aria-label="Curve graph">
        <canvas id="curve" width="420" height="420" tabindex="1"></canvas>
        <div id="y-axis-labels" aria-hidden="true">
          <span>127</span><span>OUT</span><span>0</span></div>
        <div id="x-axis-labels" aria-hidden="true">
          <span>0</span><span>IN</span><span>127</span></div>
      </div>

      <div class="mode-controls" aria-label="Curve mode selection">
        <label><input type="radio" name="mode" value="linear" />Linear</label>
        <label><input type="radio" name="mode" value="smooth" />Smooth</label>
        <label><input type="radio" name="mode" value="monotonic" />Monoton</label>
        <label><input type="radio" name="mode" value="natural" />Natural</label>
        <label><input type="radio" name="mode" value="bspline" checked />Bezier</label>
      </div>

      <div id="sfz-graph-container" aria-label="SFZ output graph">
        <canvas id="sfz-graph" width="420" height="420"></canvas>
      </div>
    </div>

    <div id="output-container" aria-label="SFZ output code">
      <pre id="output">// SFZ velocity curve output will appear here</pre>
      <div style="display: flex; align-items: center;">
        <button class="copy-btn" id="copyBtn">Copy code</button>
        <span id="copy-message" aria-live="polite" aria-atomic="true" class="">Copied!</span>
      </div>
    </div>
  </div>

  <script>
    function createMonotoneCubicSpline(xs, ys) {
      if (xs.length < 2) return x => ys[0];
      const n = xs.length;
      const dx = [], dy = [], ms = [];
      for (let i = 0; i < n - 1; i++) {
        dx[i] = xs[i + 1] - xs[i]; dy[i] = ys[i + 1] - ys[i]; ms[i] = dy[i] / dx[i];
      }
      const c1 = [ms[0]];
      for (let i = 1; i < n - 1; i++) {
        if (ms[i - 1] * ms[i] <= 0) c1[i] = 0;
        else {
          const w1 = 2 * dx[i] + dx[i - 1], w2 = dx[i] + 2 * dx[i - 1];
          c1[i] = (w1 + w2) / (w1 / ms[i - 1] + w2 / ms[i]);
        }
      }
      c1[n - 1] = ms[n - 2];
      const c2 = [], c3 = [];
      for (let i = 0; i < n - 1; i++) {
        const invDx = 1 / dx[i];
        const common = c1[i] + c1[i + 1] - 2 * ms[i];
        c2[i] = (ms[i] - c1[i] - common) * invDx;
        c3[i] = common * invDx * invDx;
      }
      return x => {
        let i = n - 2;
        if (x <= xs[0]) i = 0;
        else if (x >= xs[n - 1]) i = n - 2;
        else {
          let low = 0, high = n - 2;
          while (low <= high) {
            const mid = Math.floor((low + high) / 2);
            if (xs[mid] <= x && x <= xs[mid + 1]) {
              i = mid;
              break;
            } else if (x < xs[mid]) {
              high = mid - 1;
            } else low = mid + 1;
          }
        }
        const diff = x - xs[i];
        return ys[i] + c1[i] * diff + c2[i] * diff * diff + c3[i] * diff * diff * diff;
      };
    }

    function createNaturalCubicSpline(xs, ys) {
      const n = xs.length;
      const a = ys.slice();
      const h = [];
      for (let i = 0; i < n - 1; i++) h[i] = xs[i + 1] - xs[i];
      const al = [0];
      for (let i = 1; i < n - 1; i++)
        al[i] = (3 / h[i]) * (a[i + 1] - a[i]) - (3 / h[i - 1]) * (a[i] - a[i - 1]);
      const l = [1], mu = [0], z = [0];
      for (let i = 1; i < n - 1; i++) {
        l[i] = 2 * (xs[i + 1] - xs[i - 1]) - h[i - 1] * mu[i - 1];
        mu[i] = h[i] / l[i];
        z[i] = (al[i] - h[i - 1] * z[i - 1]) / l[i];
      }
      l[n - 1] = 1; z[n - 1] = 0;
      const c = Array(n).fill(0);
      const b = Array(n - 1).fill(0);
      const d = Array(n - 1).fill(0);
      for (let j = n - 2; j >= 0; j--) {
        c[j] = z[j] - mu[j] * c[j + 1];
        b[j] = (a[j + 1] - a[j]) / h[j] - h[j] * (c[j + 1] + 2 * c[j]) / 3;
        d[j] = (c[j + 1] - c[j]) / (3 * h[j]);
      }
      return x => {
        if (x <= xs[0]) return a[0];
        if (x >= xs[n - 1]) return a[n - 1];
        let i = 0;
        while (i < n - 2 && x > xs[i + 1]) i++;
        const diff = x - xs[i];
        return a[i] + b[i] * diff + c[i] * diff * diff + d[i] * diff * diff * diff;
      };
    }


    // Evaluate point on a uniform clamped B-spline curve using the De Boor algorithm
    // Arguments:
    //   points — array of control points [{x, y}, ...]
    //   degree — spline degree (e.g., 3 for cubic)
    //   t      — parameter in [0, 1], normalized curve position
    function bsplineControlPoints(points, degree, t) {

      const n = points.length - 1;    // last control-point index
      const k = degree;               // B-spline degree
      const m = n + k + 1;            // last knot index

      // --- Construct a uniform, clamped knot vector ---
      const knots = [];
      for (let i = 0; i <= m; i++) {
        if (i <= k) knots.push(0);                // start clamped
        else if (i >= m - k) knots.push(1);       // end clamped
        else knots.push((i - k) / (m - 2 * k));   // uniform interior spacing
      }

      // --- Keep parameter t within the valid domain ---
      // Guarantees i-k+j stays within bounds without manual clamping.
      if (t < 0) t = 0;
      if (t > 1) t = 1 - 1e-12; // slight offset avoids hitting final zero-width interval

      // --- Locate knot span "i" such that knots[i] ≤ t < knots[i+1] ---
      let i = k; // starting guess (safe lower bound)
      for (; i < m - k; i++) {
        if (t >= knots[i] && t < knots[i + 1]) break;
      }
      // If t == 1 exactly, assign final span
      if (t >= knots[m - k]) i = n;

      // --- Initialize de Boor points ---
      const d = [];
      for (let j = 0; j <= k; j++) {
        // Now safe: i-k+j always in [0, n]
        const idx = i - k + j;
        d[j] = { x: points[idx].x, y: points[idx].y };
      }

      // --- Perform De Boor recursion (iterative form) ---
      for (let r = 1; r <= k; r++) {
        for (let j = k; j >= r; j--) {
          const left = knots[i - k + j];
          const right = knots[i + 1 + j - r];
          const denom = right - left;

          // Avoid division by zero (shouldn’t happen with proper knots)
          const alpha = denom > 1e-12 ? (t - left) / denom : 0;

          d[j] = {
            x: (1 - alpha) * d[j - 1].x + alpha * d[j].x,
            y: (1 - alpha) * d[j - 1].y + alpha * d[j].y,
          };
        }
      }

      // Final evaluated B-spline point
      return d[k];
    }


    class CanvasSpliner {
      constructor() {
        this.canvas = document.getElementById('curve');
        this.ctx = this.canvas.getContext('2d');
        this.w = this.canvas.width;
        this.h = this.canvas.height;
        this.points = [ // initial 4 points
          { x: 0, y: this.h },
          { x: this.w / 3, y: this.h * 2 / 3 },
          { x: this.w * 2 / 3, y: this.h / 3 },
          { x: this.w, y: 0 }
        ];
        this.dragIndex = -1;
        this.mode = 'bspline';
        this.init();
        this.draw();
      }
      init() {
        this.canvas.addEventListener('mousedown', e => {
          const p = this.mousePos(e);
          const idx = this.points.findIndex(pt => Math.hypot(pt.x - p.x, pt.y - p.y) < 8);
          if (idx >= 0) this.dragIndex = idx;
          else {
            this.points.push(p);
            this.points.sort((a, b) => a.x - b.x);
          }
          this.draw();
        });
        this.canvas.addEventListener('mousemove', e => {
          if (this.dragIndex >= 0) {
            const p = this.mousePos(e);
            this.points[this.dragIndex].x = Math.min(Math.max(p.x, 0), this.w);
            this.points[this.dragIndex].y = Math.min(Math.max(p.y, 0), this.h);
            this.points.sort((a, b) => a.x - b.x);
            this.draw();
          }
        });
        window.addEventListener('mouseup', () => this.dragIndex = -1);
        this.canvas.addEventListener('dblclick', e => {
          const p = this.mousePos(e);
          const idx = this.points.findIndex(pt => Math.hypot(pt.x - p.x, pt.y - p.y) < 8);
          if (idx > 0 && idx < this.points.length - 1) {
            this.points.splice(idx, 1);
            this.draw();
          }
        });
        document.querySelectorAll('input[name="mode"]').forEach(r => {
          r.addEventListener('change', e => {
            this.setMode(e.target.value);
          });
        });
      }
      mousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        return { x: e.clientX - rect.left, y: e.clientY - rect.top };
      }
      draw() {
        this.ctx.clearRect(0, 0, this.w, this.h);
        this.ctx.lineWidth = 2;
        this.ctx.strokeStyle = '#333';
        this.ctx.fillStyle = 'red';

        switch (this.mode) {
          case 'linear': this.drawLinear(); break;
          case 'smooth': this.drawSmooth(); break;
          case 'monotonic': this.drawMonotonic(); break;
          case 'natural': this.drawNatural(); break;
          case 'bspline': this.drawBSpline(); break;
          default: this.drawLinear(); break;
        }

        for (const p of this.points) {
          this.ctx.beginPath();
          this.ctx.arc(p.x, p.y, 6, 0, 2 * Math.PI);
          this.ctx.fill();
          this.ctx.stroke();
        }

        this.drawAxisLabels();
        this.updateOutput();
        this.drawSFZGraph();
      }
      
      drawLinear() {
        this.ctx.beginPath();
        this.ctx.moveTo(this.points[0].x, this.points[0].y);
        for (let i = 1; i < this.points.length; i++) {
          this.ctx.lineTo(this.points[i].x, this.points[i].y);
        }
        this.ctx.stroke();
      }
      drawSmooth() {
        const pts = this.points;
        const ctx = this.ctx;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 0; i < pts.length - 1; i++) {
          const p0 = (i === 0) ? pts[i] : pts[i - 1];
          const p1 = pts[i];
          const p2 = pts[i + 1];
          const p3 = (i + 2 < pts.length) ? pts[i + 2] : pts[i + 1];
          for (let t = 0; t <= 1; t += 0.05) {
            ctx.lineTo(this.catmullRom(t, p0.x, p1.x, p2.x, p3.x), this.catmullRom(t, p0.y, p1.y, p2.y, p3.y));
          }
        }
        ctx.stroke();
      }
      drawMonotonic() {
        const xs = this.points.map(p => p.x);
        const ys = this.points.map(p => 127 - (p.y / this.h) * 127);
        if (xs.length < 2) return;
        const interp = createMonotoneCubicSpline(xs, ys);
        this.ctx.beginPath();
        for (let px = 0; px <= this.w; px++) {
          let yv = interp(px);
          yv = Math.min(127, Math.max(0, yv));
          const cy = ((127 - yv) * this.h) / 127;
          if (px === 0) this.ctx.moveTo(px, cy);
          else this.ctx.lineTo(px, cy);
        }
        this.ctx.stroke();
      }
      drawNatural() {
        const xs = this.points.map(p => p.x);
        const ys = this.points.map(p => 127 - (p.y / this.h) * 127);
        if (xs.length < 2) return;
        const interp = createNaturalCubicSpline(xs, ys);
        this.ctx.beginPath();
        for (let px = 0; px <= this.w; px++) {
          let yv = interp(px);
          yv = Math.min(127, Math.max(0, yv));
          const cy = ((127 - yv) * this.h) / 127;
          if (px === 0) this.ctx.moveTo(px, cy);
          else this.ctx.lineTo(px, cy);
        }
        this.ctx.stroke();
      }
      drawBSpline() {
        if (this.points.length < 4) return;
        const ctx = this.ctx;
        ctx.beginPath();
        const step = 1 / this.w;
        for (let t = 0; t <= 1; t += step) {
          const p = bsplineControlPoints(this.points, 3, t);
          if (t === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        this.ctx.stroke();
      }
      catmullRom(t, p0, p1, p2, p3) {
        return 0.5 * ((2 * p1) + (-p0 + p2) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t * t + (-p0 + 3 * p1 - 3 * p2 + p3) * t * t * t);
      }
      drawAxisLabels() {
        this.ctx.font = "12px Arial";
        this.ctx.fillStyle = "black";
        this.ctx.textAlign = "right";
        this.ctx.textBaseline = "middle";
        this.ctx.fillText("127", -8, 8);
        this.ctx.fillText("OUT", -12, this.h / 2);
        this.ctx.fillText("0", -8, this.h - 8);
        this.ctx.textAlign = "center";
        this.ctx.textBaseline = "top";
        this.ctx.fillText("0", 0, this.h + 6);
        this.ctx.fillText("IN", this.w / 2, this.h + 16);
        this.ctx.fillText("127", this.w, this.h + 6);
      }
      updateOutput() {
        const n = 128;
        const xs = this.points.map(p => p.x);
        const ys = this.points.map(p => 127 - (p.y / this.h) * 127);
        let sorted = xs.map((x, i) => ({ x, y: ys[i] })).sort((a, b) => a.x - b.x);
        const X = sorted.map(p => p.x);
        const Y = sorted.map(p => p.y);

        let interp;
        switch (this.mode) {
          case 'linear':
            interp = x => {
              let i = 0;
              while (i < X.length - 1 && x > X[i + 1]) i++;
              if (i >= X.length - 1) return Y[Y.length - 1];
              const span = X[i + 1] - X[i];
              const frac = span ? (x - X[i]) / span : 0;
              return Y[i] + frac * (Y[i + 1] - Y[i]);
            };
            break;
          case 'monotonic':
            interp = createMonotoneCubicSpline(X, Y);
            break;
          case 'natural':
            interp = createNaturalCubicSpline(X, Y);
            break;
          case 'bspline':
            interp = x => {
              if (X.length < 4) return Y[0];
              const tNorm = (x - X[0]) / (X[X.length - 1] - X[0]);
              const p = bsplineControlPoints(sorted, 3, Math.min(1, Math.max(0, tNorm)));
              return ((p.y) * 127) / 127;
            };
            break;
          default: // smooth
            interp = x => {
              if (X.length < 2) return Y[0];
              let seg = 0;
              while (seg < X.length - 2 && x > X[seg + 1]) seg++;
              const p0x = seg === 0 ? X[seg] : X[seg - 1];
              const p1x = X[seg];
              const p2x = X[seg + 1];
              const p3x = seg + 2 < X.length ? X[seg + 2] : X[seg + 1];
              const p0y = seg === 0 ? Y[seg] : Y[seg - 1];
              const p1y = Y[seg];
              const p2y = Y[seg + 1];
              const p3y = seg + 2 < Y.length ? Y[seg + 2] : Y[seg + 1];

              const t = (x - p1x) / (p2x - p1x);
              return 0.5 * (2 * p1y + (-p0y + p2y) * t + (2 * p0y - 5 * p1y + 4 * p2y - p3y) * t * t + (-p0y + 3 * p1y - 3 * p2y + p3y) * t * t * t);
            };
        }
        const output = ['<curve>', 'curve_index=18'];
        let lineParts = [];
        for (let i = 0; i < n; i++) {
          const sampleX = X[0] + ((X[X.length - 1] - X[0]) * i) / (n - 1);
          let val = interp(sampleX);
          val = Math.min(127, Math.max(0, val));
          val = (val / 127).toFixed(5);
          lineParts.push(`v${String(i).padStart(3, '0')}=${val}`);
          if (lineParts.length === 4) {
            output.push(lineParts.join(' '));
            lineParts = [];
          }
        }
        if (lineParts.length > 0) output.push(lineParts.join(' '));
        document.getElementById('output').textContent = output.join('\n');
      }
      setMode(mode) {
        this.mode = mode;
        this.draw();
      }
      drawSFZGraph() {
        const canvas = document.getElementById('sfz-graph');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        // Grid lines vertical GREY
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 128; i += 8) {
          const x = (i / 127) * width;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        // Grid lines vertical BLACK
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 128; i += 32) {
          const x = (i / 127) * width;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        // Grid lines horizontal GREY
        ctx.strokeStyle = '#ccc';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 128; i += 8) {
          const y = (i / 127) * height;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
        // Grid lines horizontal BLACK
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 128; i += 32) {
          const y = (i / 127) * height;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }


        const lines = document.getElementById('output').textContent.split('\n');
        const values = [];
        for (const line of lines) {
          if (line.startsWith('<curve>') || line.startsWith('curve_index')) continue;
          const parts = line.trim().split(' ');
          for (const p of parts) {
            const eqIdx = p.indexOf('=');
            if (eqIdx > 0) {
              const val = parseFloat(p.substring(eqIdx + 1));
              if (!isNaN(val)) values.push(val);
            }
          }
        }
        if (values.length === 0) return;

        ctx.strokeStyle = '#336699';
        ctx.fillStyle = '#003366';
        ctx.lineWidth = 2;
        ctx.beginPath();
        values.forEach((v, i) => {
          const x = (i / (values.length - 1)) * width;
          const y = height - v * height;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();

        values.forEach((v, i) => {
          const x = (i / (values.length - 1)) * width;
          const y = height - v * height;
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, 2 * Math.PI);
          ctx.fill();
        });
      }
    }

    const spline = new CanvasSpliner();

    const copyBtn = document.getElementById("copyBtn");
    const copyMsg = document.getElementById("copy-message");
    copyMsg.style.opacity = 0;

    copyBtn.addEventListener("click", () => {
      navigator.clipboard.writeText(document.getElementById("output").textContent);
      copyMsg.classList.add("visible");
      setTimeout(() => copyMsg.classList.remove("visible"), 2000);
    });
  </script>
</body>

</html>